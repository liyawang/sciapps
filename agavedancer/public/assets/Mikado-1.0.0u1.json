{
  "id": "Mikado-1.0.0u1",
  "name": "Mikado",
  "icon": null,
  "uuid": "8705314451741863450-242ac118-0001-005",
  "parallelism": "SERIAL",
  "defaultProcessorsPerNode": 1,
  "defaultMemoryPerNode": 1,
  "defaultNodeCount": 1,
  "defaultMaxRunTime": null,
  "defaultQueue": null,
  "version": "1.0.0",
  "revision": 1,
  "isPublic": true,
  "helpURI": "http://mikado.readthedocs.io/en/latest/",
  "label": null,
  "owner": "rosysnake",
  "shortDescription": "Identification of expressed loci from RNA-Seq data 
 main pipeline",
  "longDescription": "Identification of expressed loci from RNA-Seq data 
 main pipeline",
  "tags": [
    "CyverseUK"
  ],
  "ontology": [
    "http://edamontology.org/operation_0362",
    "http://edamontology.org/operation_0264",
    "http://edamontology.org/operation_0436",
    "http://edamontology.org/operation_0433",
    "http://edamontology.org/topic_3512",
    "http://edamontology.org/topic_3320"
  ],
  "executionType": "CLI",
  "executionSystem": "cyverseUK-Batch2",
  "deploymentPath": "${foundation.service.apps.default.public.dir}/Mikado-1.0.0u1.zip",
  "deploymentSystem": "data.iplantcollaborative.org",
  "templatePath": "wrapper-1.0.0b10.sh",
  "testPath": "test.sh",
  "checkpointable": false,
  "lastModified": "2017-02-28T11:22:49.000-06:00",
  "modules": [],
  "available": true,
  "inputs": [
    {
      "id": "reference",
      "value": {
        "validator": null,
        "visible": true,
        "required": true,
        "order": 0,
        "enquote": false,
        "default": ""
      },
      "details": {
        "label": "Genome FASTA file",
        "description": null,
        "argument": null,
        "showArgument": false,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 1,
        "maxCardinality": 1,
        "ontology": [],
        "fileTypes": []
      }
    },
    {
      "id": "gff",
      "value": {
        "validator": null,
        "visible": true,
        "required": true,
        "order": 0,
        "enquote": false,
        "default": [
          ""
        ]
      },
      "details": {
        "label": "Input GFF/GTF file(s).",
        "description": null,
        "argument": null,
        "showArgument": false,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 1,
        "maxCardinality": -1,
        "ontology": [],
        "fileTypes": []
      }
    },
    {
      "id": "list",
      "value": {
        "validator": null,
        "visible": true,
        "required": false,
        "order": 0,
        "enquote": false,
        "default": null
      },
      "details": {
        "label": "mutation file",
        "description": "List of the inputs, one by line, in the form: 
 file1  label  strandedness(true/false)",
        "argument": null,
        "showArgument": false,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": [],
        "fileTypes": []
      }
    },
    {
      "id": "scoring_file",
      "value": {
        "validator": "^*\.yaml$",
        "visible": true,
        "required": false,
        "order": 0,
        "enquote": false,
        "default": null
      },
      "details": {
        "label": "scoring file [yaml extension]",
        "description": null,
        "argument": null,
        "showArgument": false,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": [],
        "fileTypes": []
      }
    },
    {
      "id": "junction_file",
      "value": {
        "validator": null,
        "visible": true,
        "required": false,
        "order": 0,
        "enquote": false,
        "default": null
      },
      "details": {
        "label": ".bed file with splicing junctions",
        "description": null,
        "argument": null,
        "showArgument": false,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": [],
        "fileTypes": []
      }
    },
    {
      "id": "bt_file",
      "value": {
        "validator": null,
        "visible": true,
        "required": false,
        "order": 0,
        "enquote": false,
        "default": null
      },
      "details": {
        "label": "blast databasefor deriving homology informations",
        "description": null,
        "argument": null,
        "showArgument": false,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": [],
        "fileTypes": []
      }
    },
    {
      "id": "orfs",
      "value": {
        "validator": null,
        "visible": true,
        "required": true,
        "order": 0,
        "enquote": false,
        "default": [
          ""
        ]
      },
      "details": {
        "label": "ORF BED file(s)",
        "description": null,
        "argument": null,
        "showArgument": false,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 1,
        "maxCardinality": -1,
        "ontology": [],
        "fileTypes": []
      }
    }
  ],
  "parameters": [
    {
      "id": "con_labels",
      "value": {
        "visible": true,
        "required": false,
        "type": "string",
        "order": 0,
        "enquote": false,
        "default": null,
        "validator": "^\S*$"
      },
      "details": {
        "label": "label",
        "description": "Labels to attach to the IDs of the transcripts of the input files, separated by comma.",
        "argument": "--labels ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "pick_no_cds",
      "value": {
        "visible": true,
        "required": false,
        "type": "flag",
        "order": 0,
        "enquote": false,
        "default": false,
        "validator": null
      },
      "details": {
        "label": "no cds",
        "description": "Flag. If set, not CDS information will be printed out in the GFF output files.",
        "argument": "--no_cds ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "pick_verbosity",
      "value": {
        "visible": true,
        "required": false,
        "type": "enumeration",
        "order": 0,
        "enquote": false,
        "default": null,
        "enum_values": [
          {
            "--verbose ": "--verbose "
          },
          {
            "--noverbose ": "--noverbose "
          }
        ]
      },
      "details": {
        "label": "verbosity of pick step",
        "description": "if --verbose is set the DEBUG mode will be activated",
        "argument": null,
        "showArgument": false,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "ser_max_reg",
      "value": {
        "visible": true,
        "required": false,
        "type": "string",
        "order": 0,
        "enquote": false,
        "default": null,
        "validator": "^\d*$"
      },
      "details": {
        "label": "max regression",
        "description": "Amount of sequence in the ORF (in %) to backtrack in order to find a valid START codon, if one is absent.",
        "argument": "--max-regression ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "ser_log_lev",
      "value": {
        "visible": true,
        "required": false,
        "type": "enumeration",
        "order": 0,
        "enquote": false,
        "default": "INFO",
        "enum_values": [
          {
            "DEBUG": "DEBUG"
          },
          {
            "INFO": "INFO"
          },
          {
            "WARN": "WARN"
          },
          {
            "ERROR": "ERROR"
          }
        ]
      },
      "details": {
        "label": "log level of serialise step",
        "description": "Log level. Default: INFO",
        "argument": "--log_level ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "con_mode",
      "value": {
        "visible": true,
        "required": false,
        "type": "enumeration",
        "order": 0,
        "enquote": false,
        "default": "permissive",
        "enum_values": [
          {
            "nosplit": "nosplit"
          },
          {
            "stringent": "stringent"
          },
          {
            "lenient": "lenient"
          },
          {
            "permissive": "permissive"
          },
          {
            "split": "split"
          }
        ]
      },
      "details": {
        "label": "configure mode",
        "description": "Mode in which Mikado will treat transcripts with multiple ORFs. 
 - nosplit: keep the transcripts whole. 
 - stringent: split multi-orf transcripts if two consecutive ORFs have both BLAST hits and none of those hits is against the same target. 
 - lenient: split multi-orf transcripts as in stringent, and additionally, also when either of the ORFs lacks a BLAST hit (but not both). 
 - permissive: like lenient, but also split when both ORFs lack BLAST hits 
 - split: split multi-orf transcripts regardless of what BLAST data is available.",
        "argument": "--mode ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "pick_flank",
      "value": {
        "visible": true,
        "required": false,
        "type": "string",
        "order": 0,
        "enquote": false,
        "default": null,
        "validator": "^\d*$"
      },
      "details": {
        "label": "flanking distance",
        "description": "Flanking distance (in bps) to group non-overlapping transcripts into a single superlocus.",
        "argument": "--flank ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "all_strand_spec",
      "value": {
        "visible": true,
        "required": false,
        "type": "flag",
        "order": 0,
        "enquote": false,
        "default": false,
        "validator": null
      },
      "details": {
        "label": "strand specific",
        "description": "Boolean flag indicating whether all the assemblies are strand-specific.",
        "argument": "--strand-specific ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "ser_max_tseq",
      "value": {
        "visible": true,
        "required": false,
        "type": "number",
        "order": 0,
        "enquote": false,
        "default": 5,
        "validator": "^\d*$"
      },
      "details": {
        "label": "max target sequences",
        "description": "Maximum number of target sequences.",
        "argument": "--max_target_seqs ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "pick_monout",
      "value": {
        "visible": true,
        "required": false,
        "type": "string",
        "order": 0,
        "enquote": false,
        "default": null,
        "validator": null
      },
      "details": {
        "label": "monoloci output",
        "description": null,
        "argument": "--monoloci_out ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "con_full",
      "value": {
        "visible": true,
        "required": false,
        "type": "flag",
        "order": 0,
        "enquote": false,
        "default": false,
        "validator": null
      },
      "details": {
        "label": "full",
        "description": null,
        "argument": "--full ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "pick_log_lev",
      "value": {
        "visible": true,
        "required": false,
        "type": "enumeration",
        "order": 0,
        "enquote": false,
        "default": null,
        "enum_values": [
          {
            "DEBUG": "DEBUG"
          },
          {
            "INFO": "INFO"
          },
          {
            "WARN": "WARN"
          },
          {
            "ERROR": "ERROR"
          },
          {
            "CRITICAL": "CRITICAL"
          }
        ]
      },
      "details": {
        "label": "log level of pick step",
        "description": "Log level",
        "argument": "--log-level ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "con_scoring",
      "value": {
        "visible": true,
        "required": false,
        "type": "string",
        "order": 0,
        "enquote": false,
        "default": null,
        "validator": null
      },
      "details": {
        "label": "scoring file",
        "description": "If no file was uploaded by the user {plants.yaml,human.yaml,insects.yaml,worm.yaml} are the available scoring files",
        "argument": "--scoring ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "pick_purge",
      "value": {
        "visible": true,
        "required": false,
        "type": "flag",
        "order": 0,
        "enquote": false,
        "default": false,
        "validator": null
      },
      "details": {
        "label": "purge",
        "description": " Flag. If set, the pipeline will suppress any loci whose transcripts do not pass the requirements set in the JSON file.",
        "argument": "--purge ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "con_strand_spec",
      "value": {
        "visible": true,
        "required": false,
        "type": "string",
        "order": 0,
        "enquote": false,
        "default": null,
        "validator": null
      },
      "details": {
        "label": "strand specific assemblies",
        "description": "List of strand-specific assemblies among the inputs.",
        "argument": "--strand-specific-assemblies ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "ser_discard",
      "value": {
        "visible": true,
        "required": false,
        "type": "flag",
        "order": 0,
        "enquote": false,
        "default": false,
        "validator": null
      },
      "details": {
        "label": "discard definition",
        "description": "Flag. If set, the sequences IDs instead of their definition will be used for serialisation.",
        "argument": "--discard-definition ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    },
    {
      "id": "pick_prefix",
      "value": {
        "visible": true,
        "required": false,
        "type": "string",
        "order": 0,
        "enquote": false,
        "default": "Mikado",
        "validator": null
      },
      "details": {
        "label": "prefix",
        "description": "Prefix for the genes. Default: Mikado",
        "argument": "--prefix ",
        "showArgument": true,
        "repeatArgument": false
      },
      "semantics": {
        "minCardinality": 0,
        "maxCardinality": 1,
        "ontology": []
      }
    }
  ],
  "outputs": [],
  "_links": {
    "self": {
      "href": "https://agave.iplantc.org/apps/v2/Mikado-1.0.0u1"
    },
    "executionSystem": {
      "href": "https://agave.iplantc.org/systems/v2/cyverseUK-Batch2"
    },
    "storageSystem": {
      "href": "https://agave.iplantc.org/systems/v2/data.iplantcollaborative.org"
    },
    "history": {
      "href": "https://agave.iplantc.org/apps/v2/Mikado-1.0.0u1/history"
    },
    "metadata": {
      "href": "https://agave.iplantc.org/meta/v2/data/?q=%7B%22associationIds%22%3A%228705314451741863450-242ac118-0001-005%22%7D"
    },
    "owner": {
      "href": "https://agave.iplantc.org/profiles/v2/rosysnake"
    },
    "permissions": {
      "href": "https://agave.iplantc.org/apps/v2/Mikado-1.0.0u1/pems"
    }
  }
}
